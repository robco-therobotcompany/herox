#!/usr/bin/env python

#
# HEROX Coordinator
# Implements
#   1) Mission management (teach waypoints, store/load missions, execute mission by sending goals to move_base)
#   2) Benchmark execution (run mission X times, measure and store accuracy at each waypoint using AprilTags)
#

import os
import rospy
import rosbag
import actionlib
import tf
import glob
from mission import Mission
from waypoint import MissionWaypoint
from geometry_msgs.msg import Pose
from std_srvs.srv import Trigger
from herox_coordinator.msg import Missions
from herox_coordinator.srv import NewMission, LoadMission, SaveMission
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from actionlib_msgs.msg import GoalID

currentMission = Mission()
missionsPath = 'herox_coordinator/missions'

#
# SERVICE HANDLERS
#
def handle_load_mission(request):
  global currentMission

  print('Loading mission ' + request.name + '...')
  bag = rosbag.Bag(os.path.join(missionsPath, request.name))
  currentMission = Mission(bag)
  bag.close()
  return True

def handle_new_mission(request):
  global currentMission

  print('Creating new mission...')
  currentMission = Mission()
  return True

def get_missions():
  return [os.path.basename(p) for p in glob.glob(os.path.join(missionsPath, '*.bag'))]

def publish_missions():
  global missionPub

  missionsMsg = Missions()
  missionsMsg.missions = get_missions()
  missionPub.publish(missionsMsg)
  
def handle_save_mission(request):
  global currentMission

  print('Saving current mission to ' + request.name)
  filename = os.path.join(missionsPath, request.name)
  bag = rosbag.Bag(filename, 'w')
  currentMission.save_to_bag(bag)
  bag.close()
  publish_missions()
  return True

def handle_start_mission(request):
  global currentMission

  print('Starting mission.')

  # Reset mission waypoint counter
  currentMission.reset()

  # Send first goal to move_base
  wp = currentMission.next_waypoint()
  if wp is None:
    return(False,"Failed to start mission, no waypoint was returned")

  print('Sending waypoint ' + str(currentMission.currentGoal))
  send_waypoint(wp.pose)
  return (True, "")

def handle_add_waypoint(request):
  global currentMission

  print('Adding waypoint at current pose')
  pose = get_robot_pose()
  currentMission.add_waypoint(pose)
  return (True, "")

def handle_stop_mission(request):
  global currentMission
  global mbClient

  print('Stopping mission.')
  mbClient.cancel_all_goals()
  return (True, "")
  
#
# SUBSCRIBER HANDLERS
#
def handle_new_waypoint(msg):
  global currentMission

  rospy.loginfo("Got new waypoint: %f,%f,%f %f,%f,%f,%f", msg.position.x, msg.position.y, msg.position.z, msg.orientation.x, msg.orientation.y, msg.orientation.z, msg.orientation.w)
  currentMission.add_waypoint(msg)

#
# ACTION CALLBACK HANDLERS
#
def handle_move_base_feedback(fb):
  rospy.loginfo("Got feedback: %s", str(fb))

def handle_move_base_done(state, result):
  global currentMission

  rospy.loginfo("move_base is done")
  rospy.loginfo("State: %s", str(state))
  rospy.loginfo("Result: %s", str(result))

  if state != actionlib.GoalStatus.SUCCEEDED:
    rospy.loginfo("move_base FAILED on waypoint %d!", currentMission.currentGoal)
    return

  # Get measurement
  rospy.loginfo("Acquiring measurement for waypoint...")
  rospy.sleep(2)
  meas = get_measurement(currentMission.get_current_waypoint().tag)
  rospy.loginfo("Got measurement: %f,%f,%f %f,%f,%f,%f", meas.position.x, meas.position.y, meas.position.z, meas.orientation.x, meas.orientation.y, meas.orientation.z, meas.orientation.w)

  nextWP = currentMission.next_waypoint()
  if nextWP is None:
    print('Mission finished')
    return
  
  print('Sending waypoint ' + str(currentMission.currentGoal))
  send_waypoint(nextWP.pose)

#
# HELPERS
#

def send_waypoint(pose):
  global mbClient

  goal = MoveBaseGoal()
  goal.target_pose.header.frame_id = "map"
  goal.target_pose.header.stamp = rospy.Time.now()
  goal.target_pose.pose = pose

  mbClient.send_goal(goal, done_cb=handle_move_base_done)

def get_transform_pose(source_frame, target_frame):
  (trans, rot) = tfListener.lookupTransform(source_frame, target_frame, rospy.Time(0))
  pose = Pose()
  pose.position.x = trans[0]
  pose.position.y = trans[1]
  pose.position.z = trans[2]
  pose.orientation.x = rot[0]
  pose.orientation.y = rot[1]
  pose.orientation.z = rot[2]
  pose.orientation.w = rot[3]

  return pose

def get_robot_pose():
  return get_transform_pose('/map', '/base_link')

def get_measurement(tagname):
  return get_transform_pose('/base_link', '/' + tagname)


#
# MAIN FUNCTION
#
def coordinator_main():
  global loadSrv, newSrv, saveSrv, startSrv, stopSrv, wpSrv
  global wpSub
  global mbClient
  global tfListener
  global missionPub
  global tagSub

  rospy.init_node('herox_coordinator')
  #pub = rospy.Publisher('subsystem_status', SubsystemStatus, queue_size=10)
  loadSrv = rospy.Service('load_mission', LoadMission, handle_load_mission)
  newSrv = rospy.Service('new_mission', NewMission, handle_new_mission)
  saveSrv = rospy.Service('save_mission', SaveMission, handle_save_mission)
  startSrv = rospy.Service('start_mission', Trigger, handle_start_mission)
  stopSrv = rospy.Service('stop_mission', Trigger, handle_stop_mission)
  wpSrv = rospy.Service('add_waypoint', Trigger, handle_add_waypoint)

  missionPub = rospy.Publisher('missions', Missions, queue_size=1, latch=True)
  wpSub = rospy.Subscriber('mission_waypoints', Pose, handle_new_waypoint)

  mbClient = actionlib.SimpleActionClient('move_base', MoveBaseAction)

  tfListener = tf.TransformListener()

  # Ensure missions directory exists
  if not os.path.exists(missionsPath):
    os.makedirs(missionsPath)

  publish_missions()

  print("Coordinator initialized.")
  r = rospy.Rate(5)
  while not rospy.is_shutdown():
      r.sleep()

if __name__ == '__main__':
  try:
      coordinator_main()
  except rospy.ROSInterruptException: pass
